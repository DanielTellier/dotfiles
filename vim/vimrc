" #LET
let $RTP = split(&runtimepath,',')[0]
let $VRC = $RTP.'/vimrc'
let $SDIR = $RTP.'/sessions'
let g:fugitive_git_executable = '/usr/bin/git'
let g:snippets_base_directory = $RTP.'/plugin/vim-snippets/snippets'
let g:monokai_term_italic = 1
let g:monokai_gui_italic = 1
let g:netrw_banner = 0
let g:netrw_liststyle = 3
let g:netrw_preview = 1
let g:rehash256 = 1
let &t_SI = "\e[6 q" " Change cursor to steady bar in insert mode
let &t_SR = "\e[4 q" " Change cursor to under bar in replace mode
let &t_EI = "\e[2 q" " Change cursor to steady block in normal mode


" MACRO
" Put line within parens on new line with parens on own lines
let @p = "0f(a^M^[<<LF)i^M^[<<^["


" #SET
colorscheme monokai
filetype plugin indent on
syntax on

if system('uname -s') == "Darwin\n"
    set clipboard=unnamed " Mac
else
    set clipboard=unnamedplus " Linux
endif

set autoindent autoread
set backspace=start,eol,indent
set backupdir=$HOME/.local/share/vim/backup/
set colorcolumn=90
highlight ColorColumn ctermbg=22
set complete=.,w,b,u,t
set noconfirm
set encoding=utf-8
set expandtab tabstop=4 softtabstop=4 shiftwidth=4
set fillchars=vert:\|,fold:-
set foldmethod=indent
set foldnestmax=10
set nofoldenable
set foldlevel=2
set formatoptions=tcqj
set guioptions+=k
set hidden
set history=10000
set hlsearch incsearch
set ignorecase smartcase
set laststatus=2
set list
set listchars=tab:>-,precedes:.,trail:.,extends:.,eol:$
set nocompatible
set nojoinspaces
set nostartofline
set noswapfile
set nowrap
set number relativenumber
set redrawtime=10000 " Loading syntax in files
set ruler
set runtimepath+=$HOME/.vim/after
set viminfo+=n~/.viminfo
set scrolloff=8
set showcmd
set sidescroll=1
set sidescrolloff=8
set smarttab
set splitright
set statusline=%02n:%<%f\ %h%m%r%=%-14.(%l,%c%V%)\ %P
set t_Co=256
set title
set ttyfast
" Time out on mapping after three seconds,
" Time out on key codes after a tenth of a second
set timeout timeoutlen=3000 ttimeoutlen=100
set undolevels=100
set undodir=$HOME/.local/state/vim/undo/
set undofile
set updatetime=1000
set wildignore=*.o,*.d,*.exe,*.a,*.so,*.out
set wildmenu
set wildmode=longest:full,full
set writebackup


" #FUNCTION
function! ToggleAll()
    if &number || &relativenumber || &list
        set nonumber norelativenumber nolist
    else
        set number relativenumber list
    endif
endfunction

function! ToggleHighlights()
    if &hls && v:hlsearch
        set nohlsearch
    else
        set hlsearch
    endif
endfunction

function! ToggleNumbers()
    if &relativenumber
        set norelativenumber
    elseif &number
        set nonumber
    else
        set number relativenumber
    endif
endfunction

function! ChangeFileIndentSize(curr_size, new_size)
    let l:curr_file = bufname('%')
    let l:tmp_file = '/tmp/set_vim_file_indent.txt'
    let l:curr_set = 'set tabstop='.a:curr_size.' softtabstop='.a:curr_size
    let l:new_set = 'set tabstop='.a:new_size.' softtabstop='.a:new_size
    exe '!cp '.l:curr_file.' '.l:tmp_file
    exe 'edit '.l:tmp_file
    exe l:curr_set.' noexpandtab | retab! | write'
    exe '!cat '.l:tmp_file.' > '.l:curr_file
    exe 'edit '.l:curr_file
    exe l:new_set.' expandtab | retab | write'
    exe '!rm '.l:tmp_file
endfunction

function! OpenPath(path)
    let l:tabcurr = tabpagenr()
    let l:tablast = tabpagenr('$')
    if isdirectory(a:path)
        for i in range(1, l:tablast)
            if &ft ==# "netrw"
                exe 'edit ' . a:path
                return
            endif
            exe i . 'tabnext'
        endfor
        exe l:tabcurr . 'tabnext'
    endif

    if len(bufname('%')) == 0
        exe 'edit ' . a:path
    else
        exe 'tabnew ' . a:path
    endif
endfunction

function! SplitNetrw(bufcmd, is_stay)
    exe 'normal v'
    let l:bufname = bufname('%')
    exe 'close!'

    let l:tabnext = tabpagenr() + 1
    let l:tablast = tabpagenr('$')
    let l:bufcmd = a:bufcmd
    if l:tabnext > l:tablast
        exe 'tabnew'
        let l:bufcmd = 'edit'
    else
        exe l:tabnext . 'tabnext'
    endif

    exe l:bufcmd . ' ' . l:bufname

    " If true move back to location of netrw
    if a:is_stay
        exe tabpagenr('#') . 'tabnext'
    endif
endfunction

function! SurroundMappings(map_type)
    let chars = ['`', "'", '"', '[', ']', '{', '}', '(', ')', '<', '>', 't']
    for char in chars
        if a:map_type == "word"
            exe 'nmap <leader>w'.char.' ysiw'.char
        elseif a:map_type == "line"
            exe 'nmap <leader>l'.char.' yss'.char
        elseif a:map_type == "change"
            for curr_char in chars
                if curr_char == char
                    continue
                endif
                exe 'nmap <leader>'.curr_char.char.' cs'.curr_char.char
            endfor
        elseif a:map_type == "delete"
            exe 'nmap <leader>d'.char.' ds'.char
        elseif a:map_type == "visual"
            exe 'vmap <leader>'.char.' S'.char
        endif
    endfor
endfunction

function! MkSession()
    let sfile = $RTP."/sessions/".substitute(getcwd()[1:].".vim", "/", "-", "g")
    " Close netrw before saving session
    exe '1tabnext'
    if &ft ==# "netrw"
        exe 'tabclose'
    endif
    exe 'mksession! '.sfile
endfunction

function! SoSession()
    let sfile = $RTP."/sessions/".substitute(getcwd()[1:].".vim", "/", "-", "g")
    if filereadable(sfile)
        exe 'source '.sfile
        highlight ColorColumn ctermbg=22
    else
        echo "File does not exist ".sfile
    endif
endfunction

function! OpenAfterFT()
    let l:after_file = $RTP . "/after/ftplugin/" . &ft . ".vim"
    if filereadable(after_file)
        exe 'tabnew ' . l:after_file
    else
        echo "File does not exist: " . l:after_file
    endif
endfunction


" #COMMAND
command! -nargs=+ -complete=file Grep call search#Grep_(<f-args>)

augroup spellcheck
    autocmd!
    autocmd FileType gitcommit,markdown setlocal spell spelllang=en_us
    autocmd FileType gitcommit,markdown setlocal complete+=kspell
    autocmd FileType tex,latex,context,plaintex setlocal spell spelllang=en_us
    autocmd FileType tex,latex,context,plaintex setlocal complete+=kspell
augroup end

" File templates
augroup templates
    autocmd!
    autocmd BufNewFile *.py 0r $RTP/templates/template.py
augroup END

augroup netrw
    autocmd!
    " Hack fix to make ctrl-l work properly
    autocmd FileType netrw noremap <buffer> <c-l> <c-w>l
    autocmd FileType netrw nnoremap <buffer> <silent> <nowait> <leader>i :call SplitNetrw("edit", 0)<cr>
    autocmd FileType netrw nnoremap <buffer> <silent> <nowait> <leader>o :call SplitNetrw("split", 0)<cr>
    autocmd FileType netrw nnoremap <buffer> <silent> <nowait> <leader>v :call SplitNetrw("vsplit", 0)<cr>
    autocmd FileType netrw nnoremap <buffer> <silent> <nowait> <leader>I :call SplitNetrw("edit", 1)<cr>
    autocmd FileType netrw nnoremap <buffer> <silent> <nowait> <leader>O :call SplitNetrw("split", 1)<cr>
    autocmd FileType netrw nnoremap <buffer> <silent> <nowait> <leader>V :call SplitNetrw("vsplit", 1)<cr>
    autocmd FileType netrw setlocal bufhidden=delete
augroup END

augroup misc
    autocmd!
    autocmd FileType xml setlocal noeol
    autocmd VimEnter * silent! echo -ne "\e[2 q"
    " Return to last edit position when opening files (You want this!)
    autocmd BufReadPost *
         \ if line("'\"") > 0 && line("'\"") <= line("$") |
         \   exe "normal! g`\"" |
         \ endif
augroup END


" #MAP
let mapleader="\<space>"

" Move cursor infront of closing pair symbol
let g:AutoPairsShortcutJump = "<c-p>"

" Quit vim
nnoremap <silent> <leader>qq :qa!<cr>
" Close Window
nnoremap <silent> <leader>qc :q!<cr>

" Closes all open folds
noremap zC zM

" Make session file for cwd
nnoremap <silent> <leader>sm :call MkSession()<cr>
" Source session file at cwd
nnoremap <silent> <leader>ss :call SoSession()<cr>

" Open planner
nnoremap <silent> <leader>ep :call OpenPath("~/.local/share/planner")<cr>
" Open docs
nnoremap <silent> <leader>ed :call OpenPath("$RTP/doc/common-maps.txt")<cr>
" Open vimrc
nnoremap <silent> <leader>ev :call OpenPath("$VRC")<cr>
" Open my after file type if exists
nnoremap <silent> <leader>ea :call OpenAfterFT()<cr>
" Open bashrc
nnoremap <silent> <leader>eb :call OpenPath("$HOME/.bashrc")<cr>

" Toggle highlights
nnoremap <silent> <leader>th :call ToggleHighlights()<cr>
" Toggle listchars and numbers
nnoremap <silent> <leader>ta :call ToggleAll()<cr>
" Toggle listchars
nnoremap <silent> <leader>tl
\ :if (&list) \| set nolist \| else \| set list \| endif<cr>
" Toggle numbers
nnoremap <silent> <leader>tn :call ToggleNumbers()<cr>
" Toggle netrw
" nnoremap <silent> <leader>tw :call ToggleNetrw()<cr>

" Global substitution
nnoremap <leader>rg :%s/<c-r><c-w>//g<left><left>
nnoremap <leader>rc :,$s/<c-r><c-w>//gc<left><left><left>
vnoremap <leader>rg "zy:%s/<c-r>z//g<left><left>
vnoremap <leader>rc "zy:,$s/<c-r>z//gc<left><left><left>
nnoremap <leader>rpg :%s/\(<c-r><c-w>\)/\1/g<left><left><left><left>
nnoremap <leader>rpc :,$s/\(<c-r><c-w>\)/\1/gc<left><left><left><left><left>
vnoremap <leader>rpg "zy:%s/\(<c-r>z\)/\1/g<left><left><left><left>
vnoremap <leader>rpc "zy:,$s/\(<c-r>z\)/\1/gc<left><left><left><left><left>

" Search exact match
nnoremap <leader>em /\<<c-r><c-w>\>

" Search word under cursor
nnoremap <silent> <leader>gw :Grep . all "\b<c-r><c-w>\b"<cr>:cw<cr>
" Search word user input
nnoremap <leader>gi :Grep<space>

" paste last thing yanked, not deleted
nmap ,p "0p
nmap ,P "0P

" Terminal access
nnoremap <silent> <leader>me :terminal<cr>
nnoremap <silent> <leader>mv :vertical terminal<cr>
nnoremap <silent> <leader>mh :horizontal terminal<cr>
nnoremap <silent> <leader>mt :tab terminal<cr>
" Terminal modes
tnoremap <esc> <c-\><c-n>
" Terminal window movement
tnoremap <c-h> <c-w><c-h>
tnoremap <c-j> <c-w><c-j>
tnoremap <c-k> <c-w><c-k>
tnoremap <c-l> <c-w><c-l>

" Search file under cursor
nnoremap <leader>fe gf
nnoremap <silent> <leader>fv :vertical wincmd f<cr>
nnoremap <silent> <leader>fh :horizontal wincmd f<cr>

" You Surrounds word
call SurroundMappings("word")
" You Surrounds line
call SurroundMappings("line")
" Change Surrounds
call SurroundMappings("change")
" Delete Surrounds
call SurroundMappings("delete")
" Visual Surrounds
call SurroundMappings("visual")

" Compiler make
nnoremap <silent> <leader>cm :make % <bar> redraw!<cr><cr>

" Quick Fix List next and previous
nnoremap <silent> <leader>kn :cn<cr>
nnoremap <silent> <leader>kp :cp<cr>

" Make Y behave like other capitals
nnoremap Y y$

" Keep it centered
nnoremap n nzzzv
nnoremap N Nzzzv
nnoremap J mzJ`z

" Command line mode without shift+;
nnoremap ; :
vnoremap ; :

" Faster split window navigation
nnoremap <c-h> <c-w>h
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-l> <c-w>l

" Force use of hjkl-style movement and up(c-b)/down(c-f)
map <up> <nop>
map <down> <nop>
map <left> <nop>
map <right> <nop>
map <pageup> <nop>
map <pagedown> <nop>
map <home> <nop>
map <end> <nop>
imap <up> <nop>
imap <down> <nop>
imap <left> <nop>
imap <right> <nop>
imap <pageup> <nop>
imap <pagedown> <nop>
imap <home> <nop>
imap <end> <nop>

" Remap these keys to work with hjkl-style movement
map $ <nop>
map ^ <nop>
map { <nop>
map } <nop>
noremap K {
noremap J }
noremap H ^
noremap L $

" Tabbing
nnoremap <tab> >><esc>
nnoremap <s-tab> <<<esc>
vnoremap <tab> >><esc>
vnoremap <s-tab> <<<esc>

" Change file indent size
nnoremap <silent> <leader>24i :call ChangeFileIndentSize(2, 4)<cr><cr><cr><cr>
nnoremap <silent> <leader>42i :call ChangeFileIndentSize(4, 2)<cr><cr><cr><cr>

" Allow saving of files as sudo when I forgot to start vim using sudo.
" cmap w!! w !sudo tee > /dev/null %
